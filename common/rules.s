;
; File generated by cc65 v 2.18 - Git f75657d
;
	.fopt		compiler,"cc65 v 2.18 - Git f75657d"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_memset
	.export		_set_game_rules
	.import		_clear_preprocess_helper
	.importzp	_local_x
	.importzp	_local_y
	.importzp	_local_index
	.importzp	_local_type
	.importzp	_local_temp1
	.importzp	_local_temp2
	.importzp	_array_index
	.importzp	_array_value
	.import		_objects
	.import		_obj_prop
	.import		_obj_has
	.import		_obj_is_word
	.import		_rule_exists
	.import		_map
	.import		_preproc_helper
	.import		_helpers
	.import		_last_obj_index
	.import		_last_text_index
	.import		_map_lookup
	.import		_obj_prop_lookup
	.import		_one_lshift_lookup
	.export		_parsing_state
	.export		_operator_type
	.export		_extracted_dst_count
	.export		_extracted_src_count
	.export		_extracted_dst
	.export		_extracted_src
	.export		_parsing_horizontally
	.export		_expression_start_position
	.export		_preprocess_game_rules
	.export		_new_parsing
	.export		_parse_next
	.export		_do_parsing
	.export		_finalize_parsing

.segment	"BANKDATA"

.segment	"BANKDATA"
_parsing_state:
	.res	1,$00
_operator_type:
	.res	1,$00
_extracted_dst_count:
	.res	1,$00
_extracted_src_count:
	.res	1,$00
_extracted_dst:
	.res	10,$00
_extracted_src:
	.res	10,$00
_parsing_horizontally:
	.res	1,$00
_expression_start_position:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ set_game_rules (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_set_game_rules: near

.segment	"BANKCODE"

;
; if (helpers.rules_may_have_changed==false)
;
	lda     _helpers+4
;
; return;
;
	beq     L023F
;
; helpers.rules_may_have_changed = false;
;
	lda     #$00
	sta     _helpers+4
;
; if (rule_exists[PROP_WORD])
;
	lda     _rule_exists+15
	beq     L026F
;
; helpers.something_was_word = true;
;
	lda     #$01
;
; helpers.something_was_word = false;
;
L026F:	sta     _helpers+5
;
; memset(obj_prop,0,sizeof(obj_prop));
;
	ldy     #$00
	tya
L0251:	sta     _obj_prop,y
	iny
	bne     L0251
;
; memset(obj_has, 0, sizeof(obj_has));
;
	ldy     #$1F
	lda     #$00
L0257:	sta     _obj_has,y
	dey
	bpl     L0257
;
; memset(rule_exists, false, sizeof(rule_exists));
;
	ldy     #$0F
	lda     #$00
L025D:	sta     _rule_exists,y
	dey
	bpl     L025D
;
; ObjPropSet(TYPE_TEXT,PROP_PUSH,true);
;
	lda     _obj_prop_lookup+15
	sta     _array_index
	lda     #$03
	clc
	adc     _array_index
	sta     _array_index
	lda     #$01
	sta     _array_value
	ldy     _array_index
	lda     _array_value
	sta     _obj_prop,y
;
; preprocess_game_rules();
;
	jsr     _preprocess_game_rules
;
; do_parsing();
;
	jsr     _do_parsing
;
; finalize_parsing();
;
	jmp     _finalize_parsing
;
; }
;
L023F:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ preprocess_game_rules (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_preprocess_game_rules: near

.segment	"BANKCODE"

;
; clear_preprocess_helper();
;
	jsr     _clear_preprocess_helper
;
; memset(map,PREPROCESS_EMPTY,sizeof(map));
;
	ldy     #$00
	lda     #$80
L002C:	sta     _map,y
	iny
	cpy     #$F0
	bne     L002C
;
; for (local_index=0;local_index < last_text_index;++local_index)
;
	lda     #$00
	sta     _local_index
	tax
L0272:	lda     _local_index
	cmp     _last_text_index
	txa
	sbc     #$00
	bcc     L0275
;
; }
;
	rts
;
; if (IS_KILLED(local_index))
;
L0275:	ldy     _local_index
	lda     _objects+560,y
	and     #$08
;
; continue;
;
	jne     L0273
;
; local_type = objects.type[local_index];
;
	ldy     _local_index
	lda     _objects+280,y
	sta     _local_type
;
; if (local_type == TYPE_TEXT)
;
	cmp     #$0F
	bne     L003E
;
; local_temp1 = objects.text_type[local_index];
;
	ldy     _local_index
	lda     _objects+420,y
;
; else if (obj_is_word[local_type])
;
	jmp     L0274
L003E:	ldy     _local_type
	lda     _obj_is_word,y
	jeq     L0273
;
; local_temp1 = local_type;
;
	lda     _local_type
L0274:	sta     _local_temp1
;
; local_x = objects.x[local_index];
;
	ldy     _local_index
	lda     _objects,y
	sta     _local_x
;
; local_y = objects.y[local_index];
;
	ldy     _local_index
	lda     _objects+140,y
	sta     _local_y
;
; objects.direction[local_index] &= (~DIR_ACTIVE_RULE);
;
	lda     #<(_objects+560)
	ldx     #>(_objects+560)
	clc
	adc     _local_index
	bcc     L0056
	inx
L0056:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$BF
	sta     (ptr1),y
;
; MapSet(local_x, local_y, local_temp1);
;
	ldy     _local_y
	lda     _map_lookup,y
	clc
	adc     _local_x
	sta     _array_index
	lda     _local_temp1
	sta     _array_value
	ldy     _array_index
	lda     _array_value
	sta     _map,y
;
; SetMinMaxHelper(local_x, local_y); // uses array_index
;
	ldy     _local_y
	lda     _preproc_helper,y
	sta     _array_index
	ldx     #$00
	lda     _local_x
	cmp     _array_index
	bcs     L006A
	ldy     _local_y
	lda     _local_x
	sta     _preproc_helper,y
L006A:	ldy     _local_y
	lda     _preproc_helper+32,y
	sta     _array_index
	cmp     _local_x
	bcs     L0074
	ldy     _local_y
	lda     _local_x
	sta     _preproc_helper+32,y
L0074:	ldy     _local_x
	lda     _preproc_helper+12,y
	sta     _array_index
	lda     _local_y
	cmp     _array_index
	bcs     L007E
	ldy     _local_x
	lda     _local_y
	sta     _preproc_helper+12,y
L007E:	ldy     _local_x
	lda     _preproc_helper+44,y
	sta     _array_index
	cmp     _local_y
	bcs     L0273
	ldy     _local_x
	lda     _local_y
	sta     _preproc_helper+44,y
;
; for (local_index=0;local_index < last_text_index;++local_index)
;
L0273:	inc     _local_index
	jmp     L0272

.endproc

; ---------------------------------------------------------------
; void __near__ new_parsing (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_new_parsing: near

.segment	"BANKDATA"

L008F:
	.res	1,$00
L0090:
	.res	1,$00

.segment	"BANKCODE"

;
; if (parsing_state == PARSING_STATE_SET_SRC || parsing_state == PARSING_STATE_SET_SRC_AND) 
;
	lda     _parsing_state
	cmp     #$05
	beq     L027E
	cmp     #$06
	jne     L0123
;
; for (local_temp1=0;local_temp1<extracted_dst_count;++local_temp1)
;
L027E:	lda     #$00
	sta     _local_temp1
	tax
L027F:	lda     _local_temp1
	cmp     _extracted_dst_count
	txa
	sbc     #$00
	jcs     L0095
;
; for (local_temp2=0;local_temp2<extracted_src_count;++local_temp2)
;
	lda     #$00
	sta     _local_temp2
	tax
L0280:	lda     _local_temp2
	cmp     _extracted_src_count
	txa
	sbc     #$00
	jcs     L0286
;
; dst_type = extracted_dst[local_temp1];
;
	ldy     _local_temp1
	lda     _extracted_dst,y
	sta     L008F
;
; src_type = extracted_src[local_temp2];
;
	ldy     _local_temp2
	lda     _extracted_src,y
	sta     L0090
;
; if (operator_type == OPERATOR_IS)
;
	lda     _operator_type
	jne     L0284
;
; if (IS_NOUN(src_type)) // only nouns
;
	lda     L0090
	and     #$F0
	jne     L00AE
;
; if (src_type != dst_type)
;
	tax
	lda     L008F
	cmp     L0090
	jeq     L0285
;
; for (local_index = 0; local_index < last_obj_index; ++local_index)
;
	stx     _local_index
L0281:	lda     _local_index
	cmp     _last_obj_index
	txa
	sbc     #$00
	jcs     L0285
;
; if (IS_KILLED(local_index))
;
	ldy     _local_index
	lda     _objects+560,y
	and     #$08
;
; continue;
;
	bne     L0283
;
; if (objects.type[local_index] == dst_type)
;
	ldy     _local_index
	lda     _objects+280,y
	cmp     L008F
	bne     L0283
;
; if (objects.type[local_index] != TYPE_TEXT)
;
	ldy     _local_index
	lda     _objects+280,y
	cmp     #$0F
	beq     L0282
;
; array_value = objects.type[local_index];
;
	ldy     _local_index
	lda     _objects+280,y
	sta     _array_value
;
; objects.text_type[local_index] = array_value;
;
	ldy     _local_index
	lda     _array_value
	sta     _objects+420,y
;
; if (src_type == TYPE_TEXT)
;
L0282:	lda     L0090
	cmp     #$0F
	bne     L00D2
;
; if (local_index >= last_text_index)
;
	lda     _local_index
	cmp     _last_text_index
	txa
	sbc     #$00
	bcc     L00D2
;
; last_text_index = local_index + 1;
;
	lda     _local_index
	clc
	adc     #$01
	sta     _last_text_index
;
; objects.type[local_index] = src_type;
;
L00D2:	ldy     _local_index
	lda     L0090
	sta     _objects+280,y
;
; helpers.something_transformed = true;
;
	lda     #$01
	sta     _helpers+7
;
; helpers.rules_may_have_changed = true;
;
	sta     _helpers+4
;
; for (local_index = 0; local_index < last_obj_index; ++local_index)
;
L0283:	inc     _local_index
	jmp     L0281
;
; ObjPropSet(dst_type,(src_type & VALUE_MASK), true);
;
L00AE:	ldy     L008F
	lda     _obj_prop_lookup,y
	sta     _array_index
	lda     L0090
	and     #$0F
	clc
	adc     _array_index
	sta     _array_index
	lda     #$01
	sta     _array_value
	ldy     _array_index
	lda     _array_value
	sta     _obj_prop,y
;
; array_index = src_type & VALUE_MASK;
;
	lda     L0090
	and     #$0F
	sta     _array_index
;
; rule_exists[array_index] = true;
;
	ldy     _array_index
	ldx     #$00
	lda     #$01
	sta     _rule_exists,y
;
; else // operator_has
;
	jmp     L0285
;
; if (IS_NOUN(src_type)) // HAS works only for objects, to fit in uint
;
L0284:	lda     L0090
	ldx     #$00
	and     #$F0
	bne     L0285
;
; obj_has[dst_type] |= one_lshift_lookup [(src_type & VALUE_MASK)];
;
	lda     L008F
	asl     a
	bcc     L027D
	inx
	clc
L027D:	adc     #<(_obj_has)
	tay
	txa
	adc     #>(_obj_has)
	tax
	tya
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     L0090
	and     #$0F
	asl     a
	tay
	lda     _one_lshift_lookup,y
	ldx     _one_lshift_lookup+1,y
	ora     ptr1
	pha
	txa
	ora     ptr1+1
	tax
	pla
	ldy     #$00
	jsr     staxspidx
;
; for (local_temp2=0;local_temp2<extracted_src_count;++local_temp2)
;
	ldx     #$00
L0285:	inc     _local_temp2
	jmp     L0280
;
; for (local_temp1=0;local_temp1<extracted_dst_count;++local_temp1)
;
L0286:	inc     _local_temp1
	jmp     L027F
;
; if (parsing_horizontally)
;
L0095:	lda     _parsing_horizontally
	beq     L0287
;
; MapGet(expression_start_position, local_y, array_value);
;
L0105:	ldy     _local_y
	lda     _map_lookup,y
	clc
	adc     _expression_start_position
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _array_value
;
; MapSet(expression_start_position, local_y, array_value | DIR_ACTIVE_RULE);
;
	ldy     _local_y
	lda     _map_lookup,y
	clc
	adc     _expression_start_position
	sta     _array_index
	lda     _array_value
	ora     #$40
	sta     _array_value
	ldy     _array_index
	lda     _array_value
	sta     _map,y
;
; } while (expression_start_position++ < local_x-1);   
;
	lda     _expression_start_position
	inc     _expression_start_position
	jsr     pusha0
	lda     _local_x
	sec
	sbc     #$01
	bcs     L0120
	ldx     #$FF
L0120:	jsr     tosicmp
	bcc     L0105
;
; else
;
	jmp     L0123
;
; MapGet(local_x, expression_start_position, array_value);
;
L0287:	ldy     _expression_start_position
	lda     _map_lookup,y
	clc
	adc     _local_x
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _array_value
;
; MapSet(local_x, expression_start_position, array_value | DIR_ACTIVE_RULE);
;
	ldy     _expression_start_position
	lda     _map_lookup,y
	clc
	adc     _local_x
	sta     _array_index
	lda     _array_value
	ora     #$40
	sta     _array_value
	ldy     _array_index
	lda     _array_value
	sta     _map,y
;
; } while (expression_start_position++ < local_y-1);
;
	lda     _expression_start_position
	inc     _expression_start_position
	jsr     pusha0
	lda     _local_y
	sec
	sbc     #$01
	bcs     L013D
	ldx     #$FF
L013D:	jsr     tosicmp
	bcc     L0287
;
; parsing_state = PARSING_STATE_STARTING_EXPRESSION;
;
L0123:	lda     #$00
	sta     _parsing_state
;
; operator_type = OPERATOR_MAX;
;
	lda     #$03
	sta     _operator_type
;
; extracted_dst_count=0;
;
	lda     #$00
	sta     _extracted_dst_count
;
; extracted_src_count=0;   
;
	sta     _extracted_src_count
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ parse_next (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_parse_next: near

.segment	"BANKDATA"

L0147:
	.res	1,$00
L0148:
	.res	1,$00

.segment	"BANKCODE"

;
; MapGet(local_x, local_y, current_text);
;
	ldy     _local_y
	lda     _map_lookup,y
	clc
	adc     _local_x
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     L0148
;
; current_text &= (~DIR_ACTIVE_RULE);
;
	and     #$BF
	sta     L0148
;
; unexpected_text = false;
;
L0156:	lda     #$00
	sta     L0147
;
; switch (parsing_state)
;
	lda     _parsing_state
;
; }
;
	beq     L015E
	cmp     #$01
	beq     L0290
	cmp     #$03
	beq     L028E
	cmp     #$04
	beq     L0294
	cmp     #$05
	jeq     L0297
	cmp     #$06
	beq     L0294
	jmp     L015C
;
; if (parsing_horizontally)
;
L015E:	lda     _parsing_horizontally
	beq     L028D
;
; expression_start_position = local_x;
;
	lda     _local_x
;
; else
;
	jmp     L028B
;
; expression_start_position = local_y;
;
L028D:	lda     _local_y
L028B:	sta     _expression_start_position
;
; if (IS_NOUN(current_text)) // only nouns
;
L028E:	lda     L0148
	and     #$F0
	bne     L028F
;
; parsing_state = PARSING_STATE_SET_DST;
;
	lda     #$01
	sta     _parsing_state
;
; extracted_dst[extracted_dst_count] = current_text;
;
	ldy     _extracted_dst_count
	lda     L0148
	sta     _extracted_dst,y
;
; ++extracted_dst_count;
;
	inc     _extracted_dst_count
;
; return;
;
	rts
;
; else if (parsing_state == PARSING_STATE_SET_DST_AND) 
;
L028F:	lda     _parsing_state
	cmp     #$03
	bne     L015C
;
; break;
;
	jmp     L0298
;
; if (current_text == (OPERATOR_IS | AS_OPERATOR))
;
L0290:	lda     L0148
	cmp     #$20
	bne     L0291
;
; parsing_state = PARSING_STATE_STARTING_SRC;
;
	lda     #$04
	sta     _parsing_state
;
; operator_type = OPERATOR_IS;
;
	lda     #$00
	sta     _operator_type
;
; return;
;
	rts
;
; else if (current_text == (OPERATOR_AND | AS_OPERATOR))
;
L0291:	lda     L0148
	cmp     #$21
	bne     L0292
;
; parsing_state = PARSING_STATE_SET_DST_AND;
;
	lda     #$03
	sta     _parsing_state
;
; return;
;
	rts
;
; else if (current_text == (OPERATOR_HAS | AS_OPERATOR))
;
L0292:	lda     L0148
	cmp     #$22
	bne     L0298
;
; parsing_state = PARSING_STATE_STARTING_SRC;
;
	lda     #$04
	sta     _parsing_state
;
; operator_type = OPERATOR_HAS;
;
	lda     #$02
	sta     _operator_type
;
; return;
;
	rts
;
; if (IS_PROPERTY(current_text) || IS_NOUN(current_text)) // both Nouns and Props are accepted
;
L0294:	lda     L0148
	and     #$10
	bne     L0295
	lda     L0148
	and     #$F0
	bne     L0298
;
; parsing_state = PARSING_STATE_SET_SRC;
;
L0295:	lda     #$05
	sta     _parsing_state
;
; extracted_src[extracted_src_count] = current_text;
;
	ldy     _extracted_src_count
	lda     L0148
	sta     _extracted_src,y
;
; ++extracted_src_count;    
;
	inc     _extracted_src_count
;
; return;
;
	rts
;
; if (current_text == (OPERATOR_AND | AS_OPERATOR))
;
L0297:	lda     L0148
	cmp     #$21
	bne     L0298
;
; parsing_state = PARSING_STATE_SET_SRC_AND;
;
	lda     #$06
	sta     _parsing_state
;
; return;    
;
	rts
;
; unexpected_text = true;
;
L0298:	lda     #$01
	sta     L0147
;
; if (unexpected_text)
;
L015C:	lda     L0147
	beq     L01B0
;
; new_parsing();
;
	jsr     _new_parsing
;
; goto again;          
;
	jmp     L0156
;
; }
;
L01B0:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ do_parsing (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_do_parsing: near

.segment	"BANKCODE"

;
; parsing_state = PARSING_STATE_STARTING_EXPRESSION;
;
	lda     #$00
	sta     _parsing_state
;
; new_parsing();
;
	jsr     _new_parsing
;
; parsing_horizontally = true;
;
	lda     #$01
	sta     _parsing_horizontally
;
; for (local_y = 0; local_y < MAP_SIZE_Y; ++local_y)
;
	lda     #$00
	sta     _local_y
L029B:	lda     _local_y
	cmp     #$0C
	bcs     L029E
;
; local_x = preproc_helper.min_val.x[local_y];
;
	ldy     _local_y
	lda     _preproc_helper,y
	sta     _local_x
;
; if (local_x == 0xFF)
;
	cmp     #$FF
;
; continue;
;
	beq     L029D
;
; for (; local_x <= preproc_helper.max_val.x[local_y]; ++local_x)
;
L029C:	lda     _local_x
	jsr     pusha0
	ldy     _local_y
	lda     _preproc_helper+32,y
	jsr     tosicmp0
	beq     L0299
	bcs     L01C9
;
; parse_next();
;
L0299:	jsr     _parse_next
;
; for (; local_x <= preproc_helper.max_val.x[local_y]; ++local_x)
;
	inc     _local_x
	jmp     L029C
;
; new_parsing();
;
L01C9:	jsr     _new_parsing
;
; for (local_y = 0; local_y < MAP_SIZE_Y; ++local_y)
;
L029D:	inc     _local_y
	jmp     L029B
;
; parsing_horizontally = false;
;
L029E:	lda     #$00
	sta     _parsing_horizontally
;
; for (local_x = 0; local_x < MAP_SIZE_X; ++local_x)
;
	sta     _local_x
L029F:	lda     _local_x
	cmp     #$14
	bcs     L01D5
;
; local_y = preproc_helper.min_val.y[local_x];
;
	ldy     _local_x
	lda     _preproc_helper+12,y
	sta     _local_y
;
; if (local_y == 0xFF)
;
	cmp     #$FF
;
; continue;
;
	beq     L02A1
;
; for (; local_y <= preproc_helper.max_val.y[local_x]; ++local_y)
;
L02A0:	lda     _local_y
	jsr     pusha0
	ldy     _local_x
	lda     _preproc_helper+44,y
	jsr     tosicmp0
	beq     L029A
	bcs     L01E3
;
; parse_next();
;
L029A:	jsr     _parse_next
;
; for (; local_y <= preproc_helper.max_val.y[local_x]; ++local_y)
;
	inc     _local_y
	jmp     L02A0
;
; new_parsing();
;
L01E3:	jsr     _new_parsing
;
; for (local_x = 0; local_x < MAP_SIZE_X; ++local_x)
;
L02A1:	inc     _local_x
	jmp     L029F
;
; }
;
L01D5:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ finalize_parsing (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_finalize_parsing: near

.segment	"BANKCODE"

;
; for (local_index = 0; local_index < last_text_index; ++local_index)
;
	lda     #$00
	sta     _local_index
	tax
L02A3:	lda     _local_index
	cmp     _last_text_index
	txa
	sbc     #$00
	bcs     L01EE
;
; if (IS_KILLED(local_index))
;
	ldy     _local_index
	lda     _objects+560,y
	and     #$08
;
; continue;
;
	bne     L02A4
;
; MapGet(objects.x[local_index], objects.y[local_index], array_value);
;
	ldy     _local_index
	lda     _objects,y
	sta     sreg
	stx     sreg+1
	ldy     _local_index
	lda     _objects+140,y
	sta     ptr1
	lda     #$00
	clc
	adc     #>(_map_lookup)
	sta     ptr1+1
	ldy     #<(_map_lookup)
	lda     (ptr1),y
	clc
	adc     sreg
	sta     _array_index
	txa
	adc     sreg+1
	ldy     _array_index
	lda     _map,y
	sta     _array_value
;
; if (array_value & DIR_ACTIVE_RULE)
;
	and     #$40
	beq     L0207
;
; objects.direction[local_index] |= DIR_ACTIVE_RULE;
;
	lda     #<(_objects+560)
	ldx     #>(_objects+560)
	clc
	adc     _local_index
	bcc     L020B
	inx
L020B:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	ora     #$40
;
; else
;
	jmp     L02A2
;
; objects.direction[local_index] &= (~DIR_ACTIVE_RULE);
;
L0207:	lda     #<(_objects+560)
	ldx     #>(_objects+560)
	clc
	adc     _local_index
	bcc     L0210
	inx
L0210:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	and     #$BF
L02A2:	sta     (ptr1),y
;
; for (local_index = 0; local_index < last_text_index; ++local_index)
;
	ldx     #$00
L02A4:	inc     _local_index
	jmp     L02A3
;
; memset(obj_is_word, false, sizeof(obj_is_word));
;
L01EE:	ldy     #$0F
	lda     #$00
L0218:	sta     _obj_is_word,y
	dey
	bpl     L0218
;
; for (local_type = 0; local_type < TYPE_MAX; ++local_type)
;
	lda     #$00
	sta     _local_type
L02A5:	lda     _local_type
	cmp     #$10
	bcs     L021A
;
; ObjPropGet(local_type, PROP_WORD, array_value);
;
	ldy     _local_type
	lda     _obj_prop_lookup,y
	sta     _array_index
	lda     #$0F
	clc
	adc     _array_index
	sta     _array_index
	ldy     _array_index
	lda     _obj_prop,y
	sta     _array_value
;
; if (array_value)
;
	lda     _array_value
	beq     L02A6
;
; obj_is_word[local_type] = true;
;
	ldy     _local_type
	lda     #$01
	sta     _obj_is_word,y
;
; helpers.rules_may_have_changed = true;
;
	sta     _helpers+4
;
; for (local_type = 0; local_type < TYPE_MAX; ++local_type)
;
L02A6:	inc     _local_type
	jmp     L02A5
;
; if (helpers.rules_may_have_changed) // this should be set only if some object IS WORD
;
L021A:	lda     _helpers+4
	beq     L0237
;
; if (last_text_index < last_obj_index)
;
	lda     _last_text_index
	cmp     _last_obj_index
	bcs     L0237
;
; last_text_index = last_obj_index;
;
	lda     _last_obj_index
	sta     _last_text_index
;
; if (helpers.something_was_word)
;
L0237:	lda     _helpers+5
	beq     L023B
;
; helpers.rules_may_have_changed = true;
;
	lda     #$01
	sta     _helpers+4
;
; }
;
L023B:	rts

.endproc

