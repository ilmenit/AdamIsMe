;
; File generated by cc65 v 2.18 - Git f75657d
;
	.fopt		compiler,"cc65 v 2.18 - Git f75657d"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_joy_static_stddrv
	.import		_joy_install
	.import		_joy_read
	.import		_memcpy
	.import		_memset
	.export		_init_platform
	.export		_audio_music
	.export		_audio_sfx
	.export		_load_game_progress
	.export		_save_game_progress
	.export		_load_level_data
	.export		_set_tileset
	.export		_set_palette
	.export		_galaxy_draw_screen
	.export		_galaxy_get_action
	.export		_game_lost
	.export		_game_get_action
	.export		_game_draw_screen
	.import		_init_level
	.import		_is_level_complete
	.import		_load_level
	.importzp	_local_x
	.importzp	_local_y
	.importzp	_local_index
	.importzp	_local_type
	.importzp	_local_flags
	.importzp	_local_temp1
	.importzp	_local_temp2
	.importzp	_lookup_index
	.importzp	_array_index
	.importzp	_array_value
	.importzp	_array_ptr
	.import		_game_phase
	.import		_level_number
	.import		_you_move_direction
	.import		_game_progress
	.import		_objects
	.import		_obj_prop
	.import		_map
	.import		_helpers
	.import		_last_obj_index
	.import		_map_lookup
	.import		_obj_prop_lookup
	.import		_init_sfx
	.import		_play_sfx
	.import		_play_music
	.import		_stop_music
	.import		_pause_music
	.import		_continue_music
	.import		_open
	.import		_close
	.import		_write
	.import		_read
	.import		_lseek
	.import		_memory_handler_init
	.import		_store_state
	.import		_undo
	.import		_redo
	.import		_reset_undo
	.export		_file_read_pointer
	.export		_file_progress_pointer
	.export		_saved_completed_levels
	.export		_undo_redo_counter
	.export		_joy_status
	.export		_video_buffer_number
	.export		_video_lookup
	.export		_video_lookup1
	.export		_video_lookup2
	.import		_video_ptr1
	.import		_video_ptr2
	.import		_display_list1
	.import		_display_list2
	.import		_text_ptr
	.import		_display_font_page1
	.import		_display_font_page2
	.import		_game_font_address
	.import		_game_font_page1
	.import		_game_font_page2
	.import		_galaxy_font_address
	.import		_galaxy_font_page1
	.import		_galaxy_font_page2
	.import		_audio_only_sfx
	.import		_dl_handler
	.import		_background_color
	.export		_level_file_name
	.export		_tile_info_file_name
	.export		_progress_file_name
	.export		_font_file_name
	.export		_inverse_file_name
	.export		_atari_tiles_info
	.export		_tiles_inverse
	.export		_representation_obj
	.export		_representation_type
	.export		_representation_text
	.export		_representation_galaxy
	.export		_undo_data_stored_this_turn
	.export		_set_gray_palette
	.export		_wait_for_vblank
	.export		_palette_can_be_modified
	.export		_system_colors
	.export		_pre_disk_io_done
	.export		_pre_disk_io
	.export		_post_disk_io
	.export		_fade_to_black_one_step
	.export		_fade_screen_to_black
	.export		_fade_palette_to_level_colors
	.export		_world_level_cache
	.export		_font_inverse_cache
	.export		_galaxy_level_cache
	.export		_galaxy_inverse_cache
	.export		_galaxy_cached
	.export		_loaded_world_cache
	.export		_read_level_from_disk
	.export		_loaded_tileset
	.export		_read_font_tileset
	.export		_set_timer
	.export		_wait_for_timer
	.export		_wait_time
	.export		_wait_for_fire
	.export		_swap_video_buffer
	.export		_representation_music
	.export		_representation_sfx
	.export		_switch_music
	.export		_last_galaxy_move_direction
	.export		_perform_undo
	.export		_perform_redo
	.export		_store_undo_data
	.export		_test_quit
	.export		_draw_tile
	.export		_draw_tile2
	.export		_open_and_test_file_io
	.import		_rom_copy

.segment	"BANKDATA"

_file_read_pointer:
	.word	$FFFF
_file_progress_pointer:
	.word	$FFFF
_saved_completed_levels:
	.byte	$00
_undo_redo_counter:
	.byte	$00
_video_buffer_number:
	.byte	$00
_level_file_name:
	.addr	L004A
_tile_info_file_name:
	.addr	L004C
_progress_file_name:
	.addr	L004E
_font_file_name:
	.addr	L0050
_inverse_file_name:
	.addr	L0052
_representation_obj:
	.byte	$48
	.byte	$46
	.byte	$6C
	.byte	$72
	.byte	$7C
	.byte	$78
	.byte	$76
	.byte	$70
	.byte	$7A
	.byte	$64
	.byte	$6E
	.byte	$60
	.byte	$68
	.byte	$74
	.byte	$58
	.byte	$FF
_representation_type:
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$00
_representation_text:
	.byte	$20
	.byte	$22
	.byte	$24
	.byte	$26
	.byte	$28
	.byte	$2A
	.byte	$2C
	.byte	$2E
	.byte	$30
	.byte	$32
	.byte	$34
	.byte	$36
	.byte	$38
	.byte	$3A
	.byte	$3C
	.byte	$3E
	.byte	$00
	.byte	$02
	.byte	$04
	.byte	$06
	.byte	$08
	.byte	$0A
	.byte	$0C
	.byte	$0E
	.byte	$10
	.byte	$12
	.byte	$14
	.byte	$16
	.byte	$18
	.byte	$1A
	.byte	$1C
	.byte	$1E
	.byte	$40
	.byte	$42
	.byte	$44
_representation_galaxy:
	.byte	$2C
	.byte	$2E
	.byte	$30
	.byte	$32
	.byte	$34
	.byte	$36
	.byte	$38
	.byte	$3A
	.byte	$6C
	.byte	$6E
	.byte	$70
	.byte	$72
	.byte	$74
	.byte	$76
	.byte	$78
	.byte	$7A
	.byte	$0E
	.byte	$10
	.byte	$12
	.byte	$14
	.byte	$16
	.byte	$18
	.byte	$1A
	.byte	$1C
	.byte	$4C
	.byte	$4E
	.byte	$50
	.byte	$52
	.byte	$54
	.byte	$56
	.byte	$58
	.byte	$5A
	.byte	$40
	.byte	$42
	.byte	$44
	.byte	$46
	.byte	$48
	.byte	$4A
	.byte	$0A
	.byte	$6A
_undo_data_stored_this_turn:
	.byte	$00
_system_colors:
	.addr	_background_color
	.word	$02C4
	.word	$02C5
	.word	$02C6
	.word	$02C7
_pre_disk_io_done:
	.byte	$00
_galaxy_cached:
	.byte	$00
_loaded_world_cache:
	.byte	$FE
_loaded_tileset:
	.byte	$FF
_representation_music:
	.byte	$22
	.byte	$0E
	.byte	$00
	.byte	$12
	.byte	$24
	.byte	$22
_representation_sfx:
	.byte	$FF
	.byte	$1E
	.byte	$14
	.byte	$19
	.byte	$1D
	.byte	$1C
	.byte	$13
	.byte	$16
	.byte	$18
	.byte	$1B
	.byte	$15
	.byte	$1A
	.byte	$17
	.byte	$1F
	.byte	$20

.segment	"BANKRODATA"

L004E:
	.byte	$50,$52,$4F,$47,$52,$45,$53,$53,$2E,$44,$41,$54,$00
L004C:
	.byte	$4C,$45,$56,$45,$4C,$53,$2E,$41,$54,$4C,$00
L004A:
	.byte	$4C,$45,$56,$45,$4C,$53,$2E,$41,$49,$4D,$00
L0052:
	.byte	$30,$2E,$49,$4E,$56,$00
L0050:
	.byte	$30,$2E,$46,$4E,$54,$00

.segment	"BANKDATA"

.segment	"BANKDATA"
_joy_status:
	.res	1,$00
_video_lookup:
	.res	48,$00
_video_lookup1:
	.res	48,$00
_video_lookup2:
	.res	48,$00
_atari_tiles_info:
	.res	54,$00
_tiles_inverse:
	.res	64,$00
_palette_can_be_modified:
	.res	1,$00
_world_level_cache:
	.res	1920,$00
_font_inverse_cache:
	.res	64,$00
_galaxy_level_cache:
	.res	240,$00
_galaxy_inverse_cache:
	.res	64,$00
_last_galaxy_move_direction:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ init_platform (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_init_platform: near

.segment	"BANKCODE"

;
; init_sfx();
;
	jsr     _init_sfx
;
; pre_disk_io(); // disable Antic and NMIEN
;
	jsr     _pre_disk_io
;
; open_and_test_file_io();
;
	jsr     _open_and_test_file_io
;
; memory_handler_init();
;
	jsr     _memory_handler_init
;
; OS.keyrep = 2;
;
	lda     #$02
	sta     $02DA
;
; OS.krpdel = 8;
;
	lda     #$08
	sta     $02D9
;
; OS.noclik = 255;
;
	lda     #$FF
	sta     $02DB
;
; joy_install(joy_static_stddrv);
;
	lda     #<(_joy_static_stddrv)
	ldx     #>(_joy_static_stddrv)
	jsr     _joy_install
;
; for (local_y = 0; local_y < SCREEN_SIZE_Y; ++local_y)
;
	lda     #$00
	sta     _local_y
L0679:	lda     _local_y
	cmp     #$18
	bcs     L061F
;
; video_lookup1[local_y] = video_ptr1 + ((uint)local_y) * SCREEN_SIZE_X;
;
	ldx     #$00
	lda     _local_y
	asl     a
	bcc     L0677
	inx
	clc
L0677:	adc     #<(_video_lookup1)
	tay
	txa
	adc     #>(_video_lookup1)
	tax
	tya
	jsr     pushax
	lda     _video_ptr1
	ldx     _video_ptr1+1
	jsr     pushax
	lda     _local_y
	jsr     pusha0
	lda     #$28
	jsr     tosumula0
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; video_lookup2[local_y] = video_ptr2 + ((uint)local_y) * SCREEN_SIZE_X;
;
	ldx     #$00
	lda     _local_y
	asl     a
	bcc     L0678
	inx
	clc
L0678:	adc     #<(_video_lookup2)
	tay
	txa
	adc     #>(_video_lookup2)
	tax
	tya
	jsr     pushax
	lda     _video_ptr2
	ldx     _video_ptr2+1
	jsr     pushax
	lda     _local_y
	jsr     pusha0
	lda     #$28
	jsr     tosumula0
	jsr     tosaddax
	ldy     #$00
	jsr     staxspidx
;
; for (local_y = 0; local_y < SCREEN_SIZE_Y; ++local_y)
;
	inc     _local_y
	jmp     L0679
;
; swap_video_buffer();
;
L061F:	jsr     _swap_video_buffer
;
; rom_copy();
;
	jsr     _rom_copy
;
; OS.vdslst = &dl_handler;
;
	lda     #>(_dl_handler)
	sta     $0200+1
	lda     #<(_dl_handler)
	sta     $0200
;
; OS.color0 = 0;
;
	lda     #$00
	sta     $02C4
;
; OS.color3 = 0; // inverse color0
;
	sta     $02C7
;
; OS.color1 = 0;
;
	sta     $02C5
;
; OS.color2 = 0;
;
	sta     $02C6
;
; OS.color4 = 0;
;
	sta     $02C8
;
; GTIA_WRITE.sizem = 0xFF;
;
	lda     #$FF
	sta     $D00C
;
; GTIA_WRITE.grafm = 0xFF; // shape of Missiles
;
	sta     $D011
;
; GTIA_WRITE.hposm2 = 0x22; // left cover
;
	lda     #$22
	sta     $D006
;
; GTIA_WRITE.hposp2 = 0x2A; // left corners
;
	lda     #$2A
	sta     $D002
;
; GTIA_WRITE.hposp3 = 0xCE; // right corners
;
	lda     #$CE
	sta     $D003
;
; GTIA_WRITE.hposm3 = 0xD6; // right cover
;
	lda     #$D6
	sta     $D007
;
; OS.pcolr2 = 0x00;
;
	lda     #$00
	sta     $02C2
;
; OS.pcolr3 = 0x00;
;
	sta     $02C3
;
; OS.pcolr0 = 0xB8;
;
	lda     #$B8
	sta     $02C0
;
; OS.pcolr1 = 0xB8;
;
	sta     $02C1
;
; GTIA_WRITE.hposp0 = 0xf0; // d2
;
	lda     #$F0
	sta     $D000
;
; GTIA_WRITE.hposp1 = 0xf0; // d2
;
	sta     $D001
;
; GTIA_WRITE.hposm0 = 0xF0;
;
	sta     $D004
;
; GTIA_WRITE.hposm1 = 0xF0;
;
	sta     $D005
;
; GTIA_WRITE.gractl = GRACTL_PLAYERS; // we use memory as Players shape, not grafp
;
	lda     #$02
	sta     $D01D
;
; ANTIC.pmbase = PM_BASE_PAGE; // 0x38
;
	lda     #$38
	sta     $D407
;
; OS.gprior = 0x1; // 4
;
	lda     #$01
	sta     $026F
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ audio_music (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_audio_music: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; if (music_id == MUSIC_DISABLED)
;
	ldy     #$00
	lda     (sp),y
	bne     L067A
;
; stop_music();
;
	jsr     _stop_music
;
; else
;
	jmp     incsp1
;
; play_music(representation_music[music_id]);
;
L067A:	lda     (sp),y
	tay
	lda     _representation_music,y
	jsr     _play_music
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ audio_sfx (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_audio_sfx: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; play_sfx(representation_sfx[sfx_id]);
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     _representation_sfx,y
	jsr     _play_sfx
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ load_game_progress (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_load_game_progress: near

.segment	"BANKCODE"

;
; pre_disk_io();
;
	jsr     _pre_disk_io
;
; file_progress_pointer = open(progress_file_name, O_RDWR | O_CREAT);
;
	jsr     decsp4
	lda     _progress_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _progress_file_name+1
	sta     (sp),y
	lda     #$13
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_progress_pointer
	stx     _file_progress_pointer+1
;
; if (file_progress_pointer != -1)
;
	cpx     #$FF
	bne     L067B
	cmp     #$FF
	beq     L023F
;
; read(file_progress_pointer, &game_progress, sizeof(game_progress));
;
L067B:	jsr     decsp4
	lda     _file_progress_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_progress_pointer+1
	sta     (sp),y
	lda     #<(_game_progress)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(_game_progress)
	sta     (sp),y
	ldx     #$00
	lda     #$0E
	jsr     _read
;
; close(file_progress_pointer);
;
	lda     _file_progress_pointer
	ldx     _file_progress_pointer+1
	jsr     _close
;
; post_disk_io();
;
	jsr     _post_disk_io
;
; return true;
;
	ldx     #$00
	lda     #$01
	rts
;
; post_disk_io();
;
L023F:	jsr     _post_disk_io
;
; return false;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ save_game_progress (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_save_game_progress: near

.segment	"BANKCODE"

;
; pre_disk_io();
;
	jsr     _pre_disk_io
;
; file_progress_pointer = open(progress_file_name, O_RDWR);
;
	jsr     decsp4
	lda     _progress_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _progress_file_name+1
	sta     (sp),y
	tya
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_progress_pointer
	stx     _file_progress_pointer+1
;
; write(file_progress_pointer, &game_progress, sizeof(game_progress));
;
	jsr     decsp4
	lda     _file_progress_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_progress_pointer+1
	sta     (sp),y
	lda     #<(_game_progress)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(_game_progress)
	sta     (sp),y
	ldx     #$00
	lda     #$0E
	jsr     _write
;
; close(file_progress_pointer);
;
	lda     _file_progress_pointer
	ldx     _file_progress_pointer+1
	jmp     _close

.endproc

; ---------------------------------------------------------------
; void __near__ load_level_data (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_load_level_data: near

.segment	"BANKCODE"

;
; fade_screen_to_black();
;
	jsr     _fade_screen_to_black
;
; if (level_number == LEVEL_GALAXY)
;
	lda     _level_number
	cmp     #$40
	bne     L01E4
;
; if (saved_completed_levels != game_progress.completed_levels)
;
	lda     _game_progress+4
	cmp     _saved_completed_levels
	beq     L0680
;
; save_game_progress();
;
	jsr     _save_game_progress
;
; saved_completed_levels = game_progress.completed_levels;
;
	lda     _game_progress+4
	sta     _saved_completed_levels
;
; if (galaxy_cached==false)
;
L0680:	lda     _galaxy_cached
	bne     L01EE
;
; pre_disk_io(); 
;
	jsr     _pre_disk_io
;
; read_level_from_disk(LEVEL_GALAXY, galaxy_level_cache);
;
	lda     #$40
	jsr     pusha
	lda     #<(_galaxy_level_cache)
	ldx     #>(_galaxy_level_cache)
	jsr     _read_level_from_disk
;
; read_font_tileset(galaxy_font_address, galaxy_inverse_cache);
;
	lda     _galaxy_font_address
	ldx     _galaxy_font_address+1
	jsr     pushax
	lda     #<(_galaxy_inverse_cache)
	ldx     #>(_galaxy_inverse_cache)
	jsr     _read_font_tileset
;
; galaxy_cached = true;
;
	lda     #$01
	sta     _galaxy_cached
;
; memcpy(map, galaxy_level_cache, sizeof(map));
;
L01EE:	ldy     #$00
L0201:	lda     _galaxy_level_cache,y
	sta     _map,y
	iny
	cpy     #$F0
	bne     L0201
;
; memcpy(tiles_inverse, galaxy_inverse_cache, sizeof(tiles_inverse));
;
	ldy     #$3F
L0207:	lda     _galaxy_inverse_cache,y
	sta     _tiles_inverse,y
	dey
	bpl     L0207
;
; else
;
	jmp     _post_disk_io
;
; reset_undo();
;
L01E4:	jsr     _reset_undo
;
; if (game_progress.landed_on_world_number != loaded_world_cache)
;
	lda     _loaded_world_cache
	cmp     _game_progress+5
	beq     L020A
;
; local_temp1 = game_progress.landed_on_world_number*LEVELS_PER_WORLD;
;
	lda     _game_progress+5
	asl     a
	asl     a
	asl     a
	sta     _local_temp1
;
; pre_disk_io();
;
	jsr     _pre_disk_io
;
; for (local_index = 0; local_index < LEVELS_PER_WORLD; ++local_index)
;
	lda     #$00
	sta     _local_index
L0681:	lda     _local_index
	cmp     #$08
	bcs     L0682
;
; read_level_from_disk(local_temp1 + local_index, world_level_cache[local_index]);
;
	lda     _local_temp1
	clc
	adc     _local_index
	jsr     pusha
	lda     _local_index
	jsr     pusha0
	lda     #$F0
	jsr     tosmula0
	clc
	adc     #<(_world_level_cache)
	tay
	txa
	adc     #>(_world_level_cache)
	tax
	tya
	jsr     _read_level_from_disk
;
; for (local_index = 0; local_index < LEVELS_PER_WORLD; ++local_index)
;
	inc     _local_index
	jmp     L0681
;
; loaded_world_cache = game_progress.landed_on_world_number;
;
L0682:	lda     _game_progress+5
	sta     _loaded_world_cache
;
; memcpy(map, world_level_cache[level_number % 8], sizeof(map));
;
L020A:	lda     #<(_map)
	ldx     #>(_map)
	jsr     pushax
	lda     _level_number
	and     #$07
	jsr     pusha0
	lda     #$F0
	jsr     tosmula0
	clc
	adc     #<(_world_level_cache)
	tay
	txa
	adc     #>(_world_level_cache)
	tax
	tya
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; local_temp1 = level_number / LEVELS_PER_WORLD;
;
	lda     _level_number
	lsr     a
	lsr     a
	lsr     a
	sta     _local_temp1
;
; local_flags = atari_tiles_info[local_temp1].tileset_number;
;
	ldx     #$00
	lda     _local_temp1
	jsr     mulax6
	sta     ptr1
	txa
	clc
	adc     #>(_atari_tiles_info)
	sta     ptr1+1
	ldy     #<(_atari_tiles_info)
	lda     (ptr1),y
	sta     _local_flags
;
; if (local_flags !=0 && loaded_tileset != local_flags)
;
	lda     _local_flags
	beq     L0228
	cmp     _loaded_tileset
	beq     L0228
;
; pre_disk_io();
;
	jsr     _pre_disk_io
;
; read_font_tileset(game_font_address, font_inverse_cache);
;
	lda     _game_font_address
	ldx     _game_font_address+1
	jsr     pushax
	lda     #<(_font_inverse_cache)
	ldx     #>(_font_inverse_cache)
	jsr     _read_font_tileset
;
; loaded_tileset = local_flags;
;
	lda     _local_flags
	sta     _loaded_tileset
;
; memcpy(tiles_inverse, font_inverse_cache, sizeof(tiles_inverse));
;
L0228:	ldy     #$3F
L0237:	lda     _font_inverse_cache,y
	sta     _tiles_inverse,y
	dey
	bpl     L0237
;
; post_disk_io();
;
	jmp     _post_disk_io

.endproc

; ---------------------------------------------------------------
; void __near__ set_tileset (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_set_tileset: near

.segment	"BANKCODE"

;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; ANTIC.dmactl = 0;
;
	lda     #$00
	sta     $D400
;
; OS.sdmctl = 0;
;
	sta     $022F
;
; swap_video_buffer();
;
	jsr     _swap_video_buffer
;
; if (atari_tiles_info[level_number / LEVELS_PER_WORLD].tileset_number == 0)
;
	ldx     #$00
	lda     _level_number
	lsr     a
	lsr     a
	lsr     a
	jsr     mulax6
	sta     ptr1
	txa
	clc
	adc     #>(_atari_tiles_info)
	sta     ptr1+1
	ldy     #<(_atari_tiles_info)
	lda     (ptr1),y
	bne     L0687
;
; OS.chbas = galaxy_font_page1;
;
	lda     _galaxy_font_page1
	sta     $02F4
;
; display_font_page1 = galaxy_font_page1;
;
	lda     _galaxy_font_page1
	sta     _display_font_page1
;
; display_font_page2 = galaxy_font_page2;
;
	lda     _galaxy_font_page2
;
; else
;
	jmp     L0686
;
; OS.chbas = game_font_page1;
;
L0687:	lda     _game_font_page1
	sta     $02F4
;
; display_font_page1 = game_font_page1;
;
	lda     _game_font_page1
	sta     _display_font_page1
;
; display_font_page2 = game_font_page2;
;
	lda     _game_font_page2
L0686:	sta     _display_font_page2
;
; OS.sdmctl = DMACTL_PLAYFIELD_NORMAL | DMACTL_DMA_FETCH | DMACTL_DMA_PLAYERS | DMACTL_PMG_SINGLELINE;  // enable ANTIC
;
	lda     #$3A
	sta     $022F
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ set_palette (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_set_palette: near

.segment	"BANKCODE"

;
; palette_can_be_modified = true;
;
	lda     #$01
	sta     _palette_can_be_modified
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ galaxy_draw_screen (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_galaxy_draw_screen: near

.segment	"BANKCODE"

;
; for (local_y = 0; local_y < MAP_SIZE_Y; ++local_y)
;
	lda     #$00
	sta     _local_y
L068D:	lda     _local_y
	cmp     #$0C
	jcs     L0697
;
; for (local_x = 0; local_x < MAP_SIZE_X; ++local_x)
;
	lda     #$00
	sta     _local_x
L068E:	lda     _local_x
	cmp     #$14
	bcs     L0696
;
; MapGet(local_x, local_y, local_type);
;
	ldy     _local_y
	lda     _map_lookup,y
	clc
	adc     _local_x
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _local_type
;
; if (local_type == LEVEL_DECODE_EMPTY)
;
	cmp     #$3F
;
; else if (local_type >= DECODE_LEVEL_NUMBERS_MIN && local_type < DECODE_LEVEL_NUMBERS_MAX)
;
	beq     L0695
	lda     _local_type
	cmp     #$10
	bcc     L053F
	cmp     #$18
	bcs     L053F
;
; local_temp1 = game_progress.landed_on_world_number;
;
	lda     _game_progress+5
	sta     _local_temp1
;
; local_temp2 = local_type - DECODE_LEVEL_NUMBERS_MIN;
;
	lda     _local_type
	sec
	sbc     #$10
	sta     _local_temp2
;
; if (is_level_complete())
;
	jsr     _is_level_complete
	tax
	beq     L0548
;
; local_temp1 = representation_galaxy[local_type] + 128;
;
	ldy     _local_type
	lda     _representation_galaxy,y
	clc
	adc     #$80
;
; else
;
	jmp     L0689
;
; local_temp1 = representation_galaxy[local_type];
;
L0548:	ldy     _local_type
	lda     _representation_galaxy,y
;
; else
;
	jmp     L0689
;
; local_temp1 = representation_galaxy[local_type];
;
L053F:	ldy     _local_type
	lda     _representation_galaxy,y
	sta     _local_temp1
;
; if (POKEY_READ.random < 16)
;
	lda     $D20A
	cmp     #$10
	bcs     L055C
;
; if (local_type >= DECODE_BACKGROUND_MIN + 2 && local_type < DECODE_BACKGROUND_MAX)
;
	lda     _local_type
	cmp     #$22
	bcc     L055C
	cmp     #$25
	bcs     L055C
;
; local_temp1 = EMPTY_TILE;
;
L0695:	lda     #$7E
L0689:	sta     _local_temp1
;
; draw_tile(local_temp1);
;
L055C:	lda     _local_temp1
	jsr     _draw_tile
;
; for (local_x = 0; local_x < MAP_SIZE_X; ++local_x)
;
	inc     _local_x
	jmp     L068E
;
; for (local_y = 0; local_y < MAP_SIZE_Y; ++local_y)
;
L0696:	inc     _local_y
	jmp     L068D
;
; if (game_progress.completed_levels > 0)
;
L0697:	lda     _game_progress+4
	beq     L0698
;
; local_temp1 = (game_progress.completed_levels / 10) * 2; // *2 because 2 chars per tile
;
	lda     _game_progress+4
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	asl     a
	sta     _local_temp1
;
; local_x = MAP_SIZE_X - 2;
;
	lda     #$12
	sta     _local_x
;
; local_y = 0;
;
	lda     #$00
	sta     _local_y
;
; draw_tile(local_temp1 + 12 + 128); // 12 is 0
;
	lda     _local_temp1
	clc
	adc     #$0C
	bcc     L068B
	clc
L068B:	adc     #$80
	jsr     _draw_tile
;
; local_temp1 = (game_progress.completed_levels % 10) * 2;
;
	lda     _game_progress+4
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	asl     a
	sta     _local_temp1
;
; ++local_x;
;
	inc     _local_x
;
; draw_tile(local_temp1 + 12 + 128);
;
	lda     _local_temp1
	clc
	adc     #$0C
	bcc     L068C
	clc
L068C:	adc     #$80
	jsr     _draw_tile
;
; local_x = game_progress.galaxy_x;
;
L0698:	lda     _game_progress
	sta     _local_x
;
; local_y = game_progress.galaxy_y;
;
	lda     _game_progress+1
	sta     _local_y
;
; if (game_progress.landed_on_world_number == SHUTTLE_IN_SPACE)
;
	lda     _game_progress+5
	cmp     #$FF
	bne     L0699
;
; local_temp1 = representation_galaxy[DECODE_SHUTTLE];
;
	lda     _representation_galaxy+38
;
; else
;
	jmp     L068A
;
; local_temp1 = last_galaxy_move_direction * 2;
;
L0699:	lda     _last_galaxy_move_direction
	asl     a
L068A:	sta     _local_temp1
;
; if (video_buffer_number == 0)
;
	lda     _video_buffer_number
	bne     L0585
;
; local_temp1 += 32;
;
	lda     #$20
	clc
	adc     _local_temp1
	sta     _local_temp1
;
; draw_tile(local_temp1);
;
L0585:	lda     _local_temp1
	jsr     _draw_tile
;
; swap_video_buffer();
;
	jmp     _swap_video_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ galaxy_get_action (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_galaxy_get_action: near

.segment	"BANKDATA"

L0301:
	.res	1,$00

.segment	"BANKCODE"

;
; bool action_taken = false;
;
	lda     #$00
	sta     L0301
;
; last_galaxy_move_direction = you_move_direction % 4;
;
	lda     _you_move_direction
	and     #$03
	sta     _last_galaxy_move_direction
;
; you_move_direction = DIR_CREATED;
;
	lda     #$20
	sta     _you_move_direction
;
; if (palette_can_be_modified)
;
	lda     _palette_can_be_modified
	beq     L069F
;
; fade_palette_to_level_colors();
;
	jsr     _fade_palette_to_level_colors
;
; joy_status = joy_read(JOY_1);
;
L0307:	lda     #$00
L069F:	jsr     _joy_read
	sta     _joy_status
;
; if (OS.rtclok[2] % 16 == 0)
;
	lda     $0014
	and     #$0F
	bne     L06A0
;
; galaxy_draw_screen();
;
	jsr     _galaxy_draw_screen
;
; } while (JOY_BTN_1(joy_status));
;
L06A0:	lda     _joy_status
	and     #$10
	bne     L0307
;
; wait_for_timer();
;
	jsr     _wait_for_timer
;
; while (action_taken==false)
;
	jmp     L06B6
;
; OS.atract = 0;
;
L06A2:	sta     $004D
;
; if (OS.rtclok[2] % 16 == 0)
;
	lda     $0014
	and     #$0F
	bne     L06A3
;
; galaxy_draw_screen();
;
	jsr     _galaxy_draw_screen
;
; action_taken = true;
;
L06A3:	lda     #$01
	sta     L0301
;
; joy_status = joy_read(JOY_1);
;
	lda     #$00
	jsr     _joy_read
	sta     _joy_status
;
; if (JOY_UP(joy_status))
;
	and     #$01
	beq     L06A4
;
; you_move_direction = DIR_UP;
;
	lda     #$02
;
; else if (JOY_RIGHT(joy_status))
;
	jmp     L069E
L06A4:	lda     _joy_status
	and     #$08
	beq     L06A5
;
; you_move_direction = DIR_RIGHT;
;
	lda     #$03
;
; else if (JOY_DOWN(joy_status))
;
	jmp     L069E
L06A5:	lda     _joy_status
	and     #$02
	beq     L06A6
;
; you_move_direction = DIR_DOWN;
;
	lda     #$00
;
; else if (JOY_LEFT(joy_status))
;
	jmp     L069E
L06A6:	lda     _joy_status
	and     #$04
	beq     L06A7
;
; you_move_direction = DIR_LEFT;
;
	lda     #$01
;
; else if (JOY_BTN_1(joy_status))
;
	jmp     L069E
L06A7:	lda     _joy_status
	and     #$10
	beq     L06A8
;
; you_move_direction = DIR_NONE;
;
	lda     #$04
L069E:	sta     _you_move_direction
;
; switch (you_move_direction)
;
L06A8:	lda     _you_move_direction
;
; }
;
	beq     L06AB
	cmp     #$01
	jeq     L06AD
	cmp     #$02
	beq     L06A9
	cmp     #$03
	jeq     L06AF
	cmp     #$04
	jeq     L06B1
	cmp     #$20
	jeq     L06B3
	jmp     L06B4
;
; if (game_progress.galaxy_y > 0)
;
L06A9:	lda     _game_progress+1
	jeq     L06B4
;
; MapGet(game_progress.galaxy_x, game_progress.galaxy_y - 1, local_type);
;
	ldx     #$00
	lda     _game_progress+1
	sec
	sbc     #$01
	bcs     L035A
	dex
L035A:	sta     ptr1
	txa
	clc
	adc     #>(_map_lookup)
	sta     ptr1+1
	ldy     #<(_map_lookup)
	lda     (ptr1),y
	clc
	adc     _game_progress
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _local_type
;
; if (local_type < DECODE_WALLS_MIN || local_type >= DECODE_WALLS_MAX)
;
	cmp     #$08
	bcc     L06AA
	lda     _local_type
	cmp     #$10
	jcc     L06B4
;
; --game_progress.galaxy_y;
;
L06AA:	dec     _game_progress+1
;
; break;
;
	jmp     L06B4
;
; if (game_progress.galaxy_y < MAP_SIZE_Y - 1)
;
L06AB:	lda     _game_progress+1
	cmp     #$0B
	jcs     L06B4
;
; MapGet(game_progress.galaxy_x, game_progress.galaxy_y + 1, local_type);
;
	ldx     #$00
	lda     _game_progress+1
	clc
	adc     #$01
	bcc     L036C
	inx
L036C:	sta     ptr1
	txa
	clc
	adc     #>(_map_lookup)
	sta     ptr1+1
	ldy     #<(_map_lookup)
	lda     (ptr1),y
	clc
	adc     _game_progress
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _local_type
;
; if (local_type < DECODE_WALLS_MIN || local_type >= DECODE_WALLS_MAX)
;
	cmp     #$08
	bcc     L06AC
	lda     _local_type
	cmp     #$10
	jcc     L06B4
;
; ++game_progress.galaxy_y;
;
L06AC:	inc     _game_progress+1
;
; break;
;
	jmp     L06B4
;
; if (game_progress.galaxy_x > 0)
;
L06AD:	lda     _game_progress
	beq     L06B4
;
; MapGet(game_progress.galaxy_x - 1, game_progress.galaxy_y, local_type);
;
	sec
	sbc     #$01
	sta     ptr1
	ldy     _game_progress+1
	lda     _map_lookup,y
	clc
	adc     ptr1
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _local_type
;
; if (local_type < DECODE_WALLS_MIN || local_type >= DECODE_WALLS_MAX)
;
	cmp     #$08
	bcc     L06AE
	lda     _local_type
	cmp     #$10
	bcc     L06B4
;
; --game_progress.galaxy_x;
;
L06AE:	dec     _game_progress
;
; break;
;
	jmp     L06B4
;
; if (game_progress.galaxy_x < MAP_SIZE_X - 1)
;
L06AF:	lda     _game_progress
	cmp     #$13
	bcs     L06B4
;
; MapGet(game_progress.galaxy_x + 1, game_progress.galaxy_y, local_type);
;
	clc
	adc     #$01
	sta     ptr1
	ldy     _game_progress+1
	lda     _map_lookup,y
	clc
	adc     ptr1
	sta     _array_index
	ldy     _array_index
	lda     _map,y
	sta     _local_type
;
; if (local_type < DECODE_WALLS_MIN || local_type >= DECODE_WALLS_MAX)
;
	cmp     #$08
	bcc     L06B0
	lda     _local_type
	cmp     #$10
	bcc     L06B4
;
; ++game_progress.galaxy_x;
;
L06B0:	inc     _game_progress
;
; break;
;
	jmp     L06B4
;
; if (game_progress.landed_on_world_number != SHUTTLE_IN_SPACE)
;
L06B1:	lda     _game_progress+5
	cmp     #$FF
	beq     L06B2
;
; game_phase = GALAXY_TRIGGER;
;
	lda     #$08
	sta     _game_phase
;
; else
;
	jmp     L06B4
;
; action_taken = false;
;
L06B2:	lda     #$00
	sta     L0301
;
; break;
;
	jmp     L06B4
;
; action_taken = false;
;
L06B3:	lda     #$00
	sta     L0301
;
; last_galaxy_move_direction = DIR_DOWN;
;
	sta     _last_galaxy_move_direction
;
; switch (GTIA_READ.consol)
;
L06B4:	lda     $D01F
;
; }
;
	beq     L06B5
	cmp     #$03
	beq     L03B5
	jmp     L06B6
;
; if (game_progress.landed_on_world_number != SHUTTLE_IN_SPACE)
;
L06B5:	lda     _game_progress+5
	cmp     #$FF
	beq     L06B6
;
; game_progress.completed_levels = 77; // 77
;
	lda     #$4D
	sta     _game_progress+4
;
; break;
;
	jmp     L06B6
;
; switch_music();
;
L03B5:	jsr     _switch_music
;
; while (action_taken==false)
;
L06B6:	lda     L0301
	jeq     L06A2
;
; if (game_progress.landed_on_world_number != SHUTTLE_IN_SPACE)
;
	lda     _game_progress+5
	cmp     #$FF
	beq     L06B7
;
; audio_sfx(SFX_YOU_MOVE);
;
	lda     #$06
	jsr     _audio_sfx
;
; last_galaxy_move_direction = you_move_direction % 4;
;
L06B7:	lda     _you_move_direction
	and     #$03
	sta     _last_galaxy_move_direction
;
; set_timer(TIMER_VALUE);
;
	lda     #$0C
	jmp     _set_timer

.endproc

; ---------------------------------------------------------------
; void __near__ game_lost (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_game_lost: near

.segment	"BANKDATA"

L042D:
	.res	1,$00

.segment	"BANKCODE"

;
; bool reload = false;
;
	lda     #$00
	sta     L042D
;
; audio_sfx(SFX_LEVEL_LOST);
;
	lda     #$03
	jsr     _audio_sfx
;
; set_gray_palette();
;
	jsr     _set_gray_palette
;
; joy_status = joy_read(JOY_1);
;
	lda     #$00
L06B8:	jsr     _joy_read
	sta     _joy_status
;
; if (JOY_BTN_1(joy_status))
;
	and     #$10
	beq     L06BA
;
; if (test_quit())
;
	jsr     _test_quit
	tax
	beq     L06B9
;
; game_phase = LEVEL_LOAD;
;
	lda     #$04
	sta     _game_phase
;
; return;
;
	rts
;
; if (JOY_LEFT(joy_status))
;
L06B9:	lda     _joy_status
	and     #$04
	beq     L06BA
;
; if (perform_undo())
;
	jsr     _perform_undo
	tax
;
; return;
;
	bne     L0433
;
; reload = true;
;
	lda     #$01
	sta     L042D
;
; if (OS.ch == 28)
;
L06BA:	lda     $02FC
	cmp     #$1C
	bne     L044A
;
; reload = true;
;
	lda     #$01
	sta     L042D
;
; if (reload)
;
L044A:	lda     L042D
	beq     L06B8
;
; load_level();
;
	jsr     _load_level
;
; init_level();
;
	jmp     _init_level
;
; }
;
L0433:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_get_action (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_game_get_action: near

.segment	"BANKCODE"

;
; you_move_direction = DIR_CREATED;
;
	lda     #$20
	sta     _you_move_direction
;
; OS.ch = 0x0; // clear key
;
	lda     #$00
	sta     $02FC
;
; GTIA_WRITE.hposp0 = 0xF0; // hide undo icon
;
	lda     #$F0
	sta     $D000
;
; GTIA_WRITE.hposp1 = 0xF0; // hide redo icon
;
	sta     $D001
;
; if (palette_can_be_modified)
;
	lda     _palette_can_be_modified
	beq     L06BD
;
; fade_palette_to_level_colors();
;
	jsr     _fade_palette_to_level_colors
;
; if (MY_PEEK(SFX_VBI_COUNTER) > 0 || helpers.you_move_at_least_once == false)
;
L06BD:	lda     $AAEE
	bne     L06BE
	lda     _helpers+3
	jne     L04B2
;
; store_undo_data(); // store only when not slowing down
;
L06BE:	jsr     _store_undo_data
;
; wait_for_timer();
;
	jsr     _wait_for_timer
;
; while (you_move_direction == DIR_CREATED && game_phase == LEVEL_ONGOING)
;
	jmp     L04B2
;
; OS.atract = 0;
;
L06BF:	lda     #$00
	sta     $004D
;
; if (OS.rtclok[2] % 16 == 0)
;
	lda     $0014
	and     #$0F
	bne     L0472
;
; game_draw_screen();
;
	jsr     _game_draw_screen
;
; joy_status = joy_read(JOY_1);
;
L0472:	lda     #$00
	jsr     _joy_read
	sta     _joy_status
;
; if (JOY_UP(joy_status))
;
	and     #$01
	beq     L06C0
;
; you_move_direction = DIR_UP;
;
	lda     #$02
;
; else if (JOY_RIGHT(joy_status))
;
	jmp     L06BC
L06C0:	lda     _joy_status
	and     #$08
	beq     L06C2
;
; if (JOY_BTN_1(joy_status))
;
	lda     _joy_status
	and     #$10
	beq     L06C1
;
; perform_redo();
;
	jsr     _perform_redo
;
; else
;
	jmp     L049F
;
; you_move_direction = DIR_RIGHT;
;
L06C1:	lda     #$03
;
; else if (JOY_DOWN(joy_status))
;
	jmp     L06BC
L06C2:	lda     _joy_status
	and     #$02
	beq     L06C3
;
; you_move_direction = DIR_DOWN;
;
	lda     #$00
;
; else if (JOY_LEFT(joy_status))
;
	jmp     L06BC
L06C3:	lda     _joy_status
	and     #$04
	beq     L049F
;
; if (JOY_BTN_1(joy_status))
;
	lda     _joy_status
	and     #$10
	beq     L06C4
;
; perform_undo();
;
	jsr     _perform_undo
;
; else
;
	jmp     L049F
;
; you_move_direction = DIR_LEFT;
;
L06C4:	lda     #$01
L06BC:	sta     _you_move_direction
;
; if (test_quit())
;
L049F:	jsr     _test_quit
	tax
	beq     L06C5
;
; if (helpers.you_move_at_least_once)
;
	lda     _helpers+3
	beq     L04A4
;
; game_phase = LEVEL_LOAD;
;
	lda     #$04
	sta     _game_phase
;
; else
;
	rts
;
; game_phase = LEVEL_QUIT;
;
L04A4:	lda     #$05
	sta     _game_phase
;
; return;
;
	rts
;
; if (GTIA_READ.consol == 3) // OPTION
;
L06C5:	lda     $D01F
	cmp     #$03
	bne     L06C6
;
; switch_music();
;
	jsr     _switch_music
;
; if (you_move_direction == DIR_CREATED) // no directin selected
;
L06C6:	lda     _you_move_direction
	cmp     #$20
	bne     L06C7
;
; store_undo_data();
;
	jsr     _store_undo_data
;
; else
;
	jmp     L04B2
;
; undo_data_stored_this_turn = false; // store undo data on the next move
;
L06C7:	lda     #$00
	sta     _undo_data_stored_this_turn
;
; while (you_move_direction == DIR_CREATED && game_phase == LEVEL_ONGOING)
;
L04B2:	lda     _you_move_direction
	cmp     #$20
	bne     L06BB
	lda     _game_phase
	cmp     #$01
	jeq     L06BF
;
; set_timer(TIMER_VALUE);
;
L06BB:	lda     #$0C
	jsr     _set_timer
;
; if (you_move_direction != DIR_NONE)
;
	lda     _you_move_direction
	cmp     #$04
	beq     L04B7
;
; helpers.you_move_at_least_once = true;
;
	lda     #$01
	sta     _helpers+3
;
; }
;
L04B7:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_screen (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_game_draw_screen: near

.segment	"BANKCODE"

;
; for (local_index = 0; local_index < last_obj_index; ++local_index)
;
	lda     #$00
	sta     _local_index
	tax
L06D3:	lda     _local_index
	cmp     _last_obj_index
	txa
	sbc     #$00
	bcc     L06E9
;
; swap_video_buffer();
;
	jmp     _swap_video_buffer
;
; if (IS_KILLED(local_index))
;
L06E9:	ldy     _local_index
	lda     _objects+560,y
	and     #$08
;
; continue;
;
	jne     L06E6
;
; local_type = objects.type[local_index];
;
	ldy     _local_index
	lda     _objects+280,y
	sta     _local_type
;
; local_x = objects.x[local_index];
;
	ldy     _local_index
	lda     _objects,y
	sta     _local_x
;
; local_y = objects.y[local_index];
;
	ldy     _local_index
	lda     _objects+140,y
	sta     _local_y
;
; if (local_type == TYPE_TEXT)
;
	lda     _local_type
	cmp     #$0F
	bne     L05A6
;
; local_type = objects.text_type[local_index];
;
	ldy     _local_index
	lda     _objects+420,y
	sta     _local_type
;
; local_temp1 = representation_text[local_type] + 128;
;
	ldy     _local_type
	lda     _representation_text,y
	clc
	adc     #$80
;
; else // objects
;
	jmp     L06D0
;
; local_temp1 = representation_obj[local_type];
;
L05A6:	ldy     _local_type
	lda     _representation_obj,y
	sta     _local_temp1
;
; local_flags = representation_type[local_type];
;
	ldy     _local_type
	lda     _representation_type,y
	sta     _local_flags
;
; if (local_flags & REPRESENTATION_DIRECTIONS)
;
	and     #$01
	beq     L06D4
;
; local_temp1 += (objects.direction[local_index] & DIR_MASK) * 2;
;
	ldy     _local_index
	lda     _objects+560,y
	and     #$07
	asl     a
	clc
	adc     _local_temp1
	sta     _local_temp1
;
; if (video_buffer_number == 0)
;
L06D4:	lda     _video_buffer_number
	bne     L05B1
;
; if (local_flags & REPRESENTATION_ANIMATED)
;
	lda     _local_flags
	and     #$02
	beq     L05C3
;
; if (local_flags & REPRESENTATION_DIRECTIONS)
;
	lda     _local_flags
	and     #$01
	beq     L06D5
;
; local_temp1 += 8;
;
	lda     #$08
;
; else
;
	jmp     L06E8
;
; local_temp1 += 2;
;
L06D5:	lda     #$02
L06E8:	clc
	adc     _local_temp1
	sta     _local_temp1
;
; ObjPropGet(local_type, PROP_WIN, array_value);
;
L05C3:	ldy     _local_type
	lda     _obj_prop_lookup,y
	sta     _array_index
	inc     _array_index
	ldy     _array_index
	lda     _obj_prop,y
	sta     _array_value
;
; if (helpers.pick_exists_as_object == false && array_value)
;
	lda     _helpers
	bne     L05B1
	lda     _array_value
	beq     L05B1
;
; local_temp1 += 128;
;
	lda     #$80
	clc
	adc     _local_temp1
L06D0:	sta     _local_temp1
;
; if (objects.direction[local_index] & DIR_ACTIVE_RULE)
;
L05B1:	ldy     _local_index
	lda     _objects+560,y
	and     #$40
	beq     L06D8
;
; local_temp1 += 128;
;
	lda     #$80
	clc
	adc     _local_temp1
	sta     _local_temp1
;
; local_temp2 = GetChar(local_x*2, local_y*2) % 128;
;
L06D8:	lda     _local_y
	asl     a
	bcc     L06CB
	ldx     #$01
L06CB:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #<(_video_lookup)
	sta     ptr1
	lda     tmp1
	adc     #>(_video_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     _local_x
	asl     a
	bcc     L06D2
	inx
	clc
L06D2:	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	lda     (ptr1),y
	and     #$7F
	sta     _local_temp2
;
; if (local_temp2 == EMPTY_TILE ||
;
	cmp     #$7E
	beq     L06E5
;
; ((video_buffer_number == 0) && ((local_temp1 % 128) < local_temp2)) ||
;
	ldx     #$00
	lda     _video_buffer_number
	bne     L06DB
	lda     _local_temp1
	and     #$7F
	cmp     _local_temp2
	bcc     L06E5
;
; ((video_buffer_number == 1) && ((local_temp1 % 128) >= local_temp2))
;
L06DB:	lda     _video_buffer_number
	cmp     #$01
	bne     L06E6
	lda     _local_temp1
	and     #$7F
	cmp     _local_temp2
	bcc     L06E6
;
; draw_tile(local_temp1);
;
L06E5:	lda     _local_temp1
	jsr     _draw_tile
;
; for (local_index = 0; local_index < last_obj_index; ++local_index)
;
	ldx     #$00
L06E6:	inc     _local_index
	jmp     L06D3

.endproc

; ---------------------------------------------------------------
; void __near__ set_gray_palette (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_set_gray_palette: near

.segment	"BANKCODE"

;
; OS.color0 = 0x08;
;
	lda     #$08
	sta     $02C4
;
; OS.color1 = 0x0A;
;
	lda     #$0A
	sta     $02C5
;
; OS.color2 = 0x04;
;
	lda     #$04
	sta     $02C6
;
; OS.color3 = 0x02;
;
	lda     #$02
	sta     $02C7
;
; if ( (background_color & 0xF0) == 0)
;
	lda     _background_color
	and     #$F0
	bne     L00D0
;
; background_color = 0x06;
;
	lda     #$06
	sta     _background_color
;
; set_palette();
;
L00D0:	jsr     _set_palette
;
; game_draw_screen();
;
	jmp     _game_draw_screen

.endproc

; ---------------------------------------------------------------
; void __near__ wait_for_vblank (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_wait_for_vblank: near

.segment	"BANKCODE"

;
; asm("lda $d40b");
;
L00D9:	lda     $d40b
;
; asm("bmi %g", w1);
;
	bmi     L00D9
;
; asm("lda $d40b");
;
L00E0:	lda     $d40b
;
; asm("bpl %g", w2);
;
	bpl     L00E0
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ pre_disk_io (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_pre_disk_io: near

.segment	"BANKCODE"

;
; ANTIC.dmactl = 0;
;
	lda     #$00
	sta     $D400
;
; OS.sdmctl = 0;
;
	sta     $022F
;
; pause_music();
;
	jsr     _pause_music
;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; ANTIC.nmien = 0;
;
	lda     #$00
	sta     $D40E
;
; pre_disk_io_done = true;
;
	lda     #$01
	sta     _pre_disk_io_done
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ post_disk_io (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_post_disk_io: near

.segment	"BANKCODE"

;
; if (pre_disk_io_done==false)
;
	lda     _pre_disk_io_done
;
; return;
;
	beq     L0100
;
; pre_disk_io_done = false;
;
	lda     #$00
	sta     _pre_disk_io_done
;
; OS.sdmctl = DMACTL_PLAYFIELD_NORMAL | DMACTL_DMA_FETCH | DMACTL_DMA_PLAYERS | DMACTL_PMG_SINGLELINE;  // enable ANTIC
;
	lda     #$3A
	sta     $022F
;
; ANTIC.nmien = NMIEN_VBI | NMIEN_DLI;
;
	lda     #$C0
	sta     $D40E
;
; continue_music();
;
	jmp     _continue_music
;
; }
;
L0100:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ fade_to_black_one_step (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_fade_to_black_one_step: near

.segment	"BANKCODE"

;
; HIDE_UNDO_ICON();
;
	lda     #$F0
	sta     $D000
;
; HIDE_REDO_ICON();
;
	sta     $D001
;
; palette_can_be_modified = false;
;
	lda     #$00
	sta     _palette_can_be_modified
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
	sta     _local_index
L06F0:	lda     _local_index
	cmp     #$05
	bcs     L0116
;
; if ((*system_colors[local_index] & 0x0F) > 0)
;
	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L06ED
	inx
	clc
L06ED:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldx     #$00
	and     #$0F
	beq     L06F1
;
; --(*system_colors[local_index]);
;
	lda     _local_index
	asl     a
	bcc     L06EE
	inx
	clc
L06EE:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; palette_can_be_modified = true;
;
	lda     #$01
	sta     _palette_can_be_modified
;
; else
;
	jmp     L06F2
;
; *system_colors[local_index] = 0;
;
L06F1:	lda     _local_index
	asl     a
	bcc     L06EF
	inx
	clc
L06EF:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	tya
	sta     (ptr1),y
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
L06F2:	inc     _local_index
	jmp     L06F0
;
; wait_for_vblank();
;
L0116:	jmp     _wait_for_vblank

.endproc

; ---------------------------------------------------------------
; void __near__ fade_screen_to_black (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_fade_screen_to_black: near

.segment	"BANKCODE"

;
; palette_can_be_modified = true;
;
	lda     #$01
	sta     _palette_can_be_modified
;
; while (palette_can_be_modified)
;
	jmp     L0131
;
; fade_to_black_one_step();
;
L012F:	jsr     _fade_to_black_one_step
;
; while (palette_can_be_modified)
;
L0131:	lda     _palette_can_be_modified
	bne     L012F
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ fade_palette_to_level_colors (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_fade_palette_to_level_colors: near

.segment	"BANKCODE"

;
; if (game_phase == LEVEL_ONGOING)
;
	lda     _game_phase
	cmp     #$01
	bne     L0135
;
; text_ptr[TEXT_OFFSET] = game_progress.landed_on_world_number + 53;
;
	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     _game_progress+5
	clc
	adc     #$35
	ldy     #$13
	sta     (ptr1),y
;
; text_ptr[TEXT_OFFSET + 1] = 62;
;
	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     #$3E
	iny
	sta     (ptr1),y
;
; text_ptr[TEXT_OFFSET + 2] = (level_number % LEVELS_PER_WORLD) + 53;
;
	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     _level_number
	and     #$07
	clc
	adc     #$35
;
; else
;
	jmp     L0705
;
; text_ptr[TEXT_OFFSET] = 0;
;
L0135:	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     #$00
	ldy     #$13
	sta     (ptr1),y
;
; text_ptr[TEXT_OFFSET + 1] = 0;
;
	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     #$00
	iny
	sta     (ptr1),y
;
; text_ptr[TEXT_OFFSET + 2] = 0;
;
	lda     _text_ptr+1
	sta     ptr1+1
	lda     _text_ptr
	sta     ptr1
	lda     #$00
L0705:	iny
	sta     (ptr1),y
;
; local_temp1 = level_number / LEVELS_PER_WORLD;
;
	lda     _level_number
	lsr     a
	lsr     a
	lsr     a
	sta     _local_temp1
;
; while (palette_can_be_modified)
;
	jmp     L0177
;
; palette_can_be_modified = false;
;
L014F:	lda     #$00
	sta     _palette_can_be_modified
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
	sta     _local_index
L0702:	lda     _local_index
	cmp     #$05
	jcs     L0156
;
; if ((*system_colors[local_index] & 0xF0) != (atari_tiles_info[local_temp1].world_colors[local_index] & 0xF0))
;
	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L06FC
	inx
	clc
L06FC:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	and     #$F0
	jsr     pusha0
	lda     _local_temp1
	jsr     mulax6
	clc
	adc     #<(_atari_tiles_info)
	tay
	txa
	adc     #>(_atari_tiles_info)
	tax
	tya
	clc
	adc     #$01
	bcc     L0163
	inx
L0163:	ldy     _local_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	and     #$F0
	jsr     tosicmp0
	beq     L015D
;
; *system_colors[local_index] = atari_tiles_info[local_temp1].world_colors[local_index] & 0xF0;
;
	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L06FD
	inx
	clc
L06FD:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	ldx     #$00
	lda     _local_temp1
	jsr     mulax6
	clc
	adc     #<(_atari_tiles_info)
	tay
	txa
	adc     #>(_atari_tiles_info)
	tax
	tya
	clc
	adc     #$01
	bcc     L0169
	inx
L0169:	ldy     _local_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	and     #$F0
	ldy     #$00
	jsr     staspidx
;
; if ((*system_colors[local_index]) < atari_tiles_info[local_temp1].world_colors[local_index])
;
L015D:	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L06FE
	inx
	clc
L06FE:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jsr     pusha0
	lda     _local_temp1
	jsr     mulax6
	clc
	adc     #<(_atari_tiles_info)
	tay
	txa
	adc     #>(_atari_tiles_info)
	tax
	tya
	clc
	adc     #$01
	bcc     L0170
	inx
L0170:	ldy     _local_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L0157
;
; ++(*system_colors[local_index]);
;
	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L06FF
	inx
	clc
L06FF:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; palette_can_be_modified = true;
;
	lda     #$01
	sta     _palette_can_be_modified
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
L0157:	inc     _local_index
	jmp     L0702
;
; if (palette_can_be_modified)
;
L0156:	lda     _palette_can_be_modified
	beq     L0177
;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; while (palette_can_be_modified)
;
L0177:	lda     _palette_can_be_modified
	jne     L014F
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
	sta     _local_index
L0703:	lda     _local_index
	cmp     #$05
	bcs     L017B
;
; *system_colors[local_index] = atari_tiles_info[local_temp1].world_colors[local_index];
;
	ldx     #$00
	lda     _local_index
	asl     a
	bcc     L0700
	inx
	clc
L0700:	adc     #<(_system_colors)
	sta     ptr1
	txa
	adc     #>(_system_colors)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	ldx     #$00
	lda     _local_temp1
	jsr     mulax6
	clc
	adc     #<(_atari_tiles_info)
	tay
	txa
	adc     #>(_atari_tiles_info)
	tax
	tya
	clc
	adc     #$01
	bcc     L0186
	inx
L0186:	ldy     _local_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; for (local_index = 0; local_index < COLORS_MAX; ++local_index)
;
	inc     _local_index
	jmp     L0703
;
; }
;
L017B:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ read_level_from_disk (unsigned char, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_read_level_from_disk: near

.segment	"BANKDATA"

L0192:
	.res	4,$00

.segment	"BANKCODE"

;
; {
;
	jsr     pushax
;
; offset = sizeof(struct level_set_header_def);
;
	ldx     #$00
	lda     #$07
	sta     L0192
	stx     L0192+1
	stx     L0192+2
	stx     L0192+3
;
; offset += (off_t)level_id * ((off_t) sizeof(map));
;
	ldy     #$02
	lda     (sp),y
	jsr     push0ax
	lda     #$F0
	jsr     tosmul0ax
	ldy     #<(L0192)
	sty     ptr1
	ldy     #>(L0192)
	jsr     laddeq
;
; lseek(file_read_pointer, offset, SEEK_SET);
;
	jsr     decsp6
	lda     _file_read_pointer
	ldy     #$04
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	lda     L0192+3
	sta     sreg+1
	lda     L0192+2
	sta     sreg
	ldx     L0192+1
	lda     L0192
	jsr     steax0sp
	ldx     #$00
	lda     #$02
	jsr     _lseek
;
; read(file_read_pointer, destination, sizeof(map));
;
	jsr     decsp4
	lda     _file_read_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldx     #$00
	lda     #$F0
	jsr     _read
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ read_font_tileset (__near__ unsigned char *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_read_font_tileset: near

.segment	"BANKDATA"

L01A4:
	.res	2,$00

.segment	"BANKCODE"

;
; {
;
	jsr     pushax
;
; close(file_read_pointer);
;
	lda     _file_read_pointer
	ldx     _file_read_pointer+1
	jsr     _close
;
; local_temp1 = level_number / LEVELS_PER_WORLD;
;
	lda     _level_number
	lsr     a
	lsr     a
	lsr     a
	sta     _local_temp1
;
; font_file_name[0] = atari_tiles_info[local_temp1].tileset_number + '0';
;
	lda     _font_file_name
	ldx     _font_file_name+1
	jsr     pushax
	ldx     #$00
	lda     _local_temp1
	jsr     mulax6
	sta     ptr1
	txa
	clc
	adc     #>(_atari_tiles_info)
	sta     ptr1+1
	ldy     #<(_atari_tiles_info)
	lda     (ptr1),y
	clc
	adc     #$30
	ldy     #$00
	jsr     staspidx
;
; file_read_pointer = open(font_file_name, O_RDONLY);
;
	jsr     decsp4
	lda     _font_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _font_file_name+1
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_read_pointer
	stx     _file_read_pointer+1
;
; if (file_read_pointer != -1)
;
	cpx     #$FF
	bne     L0707
	cmp     #$FF
	jeq     L01D5
;
; for (local_index = 0; local_index < 4; ++local_index)
;
L0707:	lda     #$00
	sta     _local_index
L0706:	lda     _local_index
	cmp     #$04
	bcs     L01B6
;
; address = font_address + local_index * (32 * 8);
;
	lda     #$00
	clc
	ldy     #$02
	adc     (sp),y
	sta     L01A4
	lda     _local_index
	iny
	adc     (sp),y
	sta     L01A4+1
;
; read(file_read_pointer, address, 32 * 8);
;
	jsr     decsp4
	lda     _file_read_pointer
	dey
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	lda     L01A4
	ldy     #$00
	sta     (sp),y
	iny
	lda     L01A4+1
	sta     (sp),y
	ldx     #$01
	lda     #$00
	jsr     _read
;
; address += 1024;
;
	lda     #$00
	clc
	adc     L01A4
	sta     L01A4
	lda     #$04
	adc     L01A4+1
	sta     L01A4+1
;
; read(file_read_pointer, address, 32 * 8);
;
	jsr     decsp4
	lda     _file_read_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	lda     L01A4
	ldy     #$00
	sta     (sp),y
	iny
	lda     L01A4+1
	sta     (sp),y
	ldx     #$01
	lda     #$00
	jsr     _read
;
; for (local_index = 0; local_index < 4; ++local_index)
;
	inc     _local_index
	jmp     L0706
;
; close(file_read_pointer);
;
L01B6:	lda     _file_read_pointer
	ldx     _file_read_pointer+1
	jsr     _close
;
; inverse_file_name[0] = atari_tiles_info[local_temp1].tileset_number + '0';
;
	lda     _inverse_file_name
	ldx     _inverse_file_name+1
	jsr     pushax
	ldx     #$00
	lda     _local_temp1
	jsr     mulax6
	sta     ptr1
	txa
	clc
	adc     #>(_atari_tiles_info)
	sta     ptr1+1
	ldy     #<(_atari_tiles_info)
	lda     (ptr1),y
	clc
	adc     #$30
	ldy     #$00
	jsr     staspidx
;
; file_read_pointer = open(inverse_file_name, O_RDONLY);
;
	jsr     decsp4
	lda     _inverse_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _inverse_file_name+1
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_read_pointer
	stx     _file_read_pointer+1
;
; if (file_read_pointer != -1)
;
	cpx     #$FF
	bne     L0708
	cmp     #$FF
	beq     L01D5
;
; read(file_read_pointer, inverse_data, TILES_MAX);
;
L0708:	jsr     decsp4
	lda     _file_read_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldx     #$00
	lda     #$40
	jsr     _read
;
; close(file_read_pointer);
;
	lda     _file_read_pointer
	ldx     _file_read_pointer+1
	jsr     _close
;
; file_read_pointer = open(level_file_name, O_RDONLY);
;
L01D5:	jsr     decsp4
	lda     _level_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _level_file_name+1
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_read_pointer
	stx     _file_read_pointer+1
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ set_timer (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_set_timer: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; MY_POKE(SFX_VBI_COUNTER, timer_value);
;
	ldy     #$00
	lda     (sp),y
	sta     $AAEE
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ wait_for_timer (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_wait_for_timer: near

.segment	"BANKCODE"

;
; while (MY_PEEK(SFX_VBI_COUNTER))
;
	jmp     L0262
;
; asm("nop");
;
L0260:	nop
;
; while (MY_PEEK(SFX_VBI_COUNTER))
;
L0262:	lda     $AAEE
	bne     L0260
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ wait_time (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_wait_time: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; set_timer(t);
;
	ldy     #$00
	lda     (sp),y
	jsr     _set_timer
;
; wait_for_timer();
;
	jsr     _wait_for_timer
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ wait_for_fire (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_wait_for_fire: near

.segment	"BANKCODE"

;
; wait_time(1);
;
L026D:	lda     #$01
	jsr     _wait_time
;
; } while (JOY_BTN_1(joy_status)==false);
;
	lda     _joy_status
	and     #$10
	beq     L026D
;
; wait_time(1);
;
L026E:	lda     #$01
	jsr     _wait_time
;
; } while (JOY_BTN_1(joy_status));
;
	lda     _joy_status
	and     #$10
	bne     L026E
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ swap_video_buffer (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_swap_video_buffer: near

.segment	"BANKCODE"

;
; if (video_buffer_number == 1)
;
	lda     _video_buffer_number
	cmp     #$01
	bne     L027F
;
; OS.sdlst = &display_list2;
;
	lda     #>(_display_list2)
	sta     $0230+1
	lda     #<(_display_list2)
	sta     $0230
;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; memset(video_ptr1, EMPTY_TILE, SCREEN_SIZE_X * SCREEN_SIZE_Y);
;
	lda     _video_ptr1
	ldx     _video_ptr1+1
	jsr     pushax
	lda     #$7E
	jsr     pusha0
	ldx     #$03
	lda     #$C0
	jsr     _memset
;
; memcpy(video_lookup, video_lookup1, sizeof(video_lookup));
;
	ldy     #$2F
L028E:	lda     _video_lookup1,y
	sta     _video_lookup,y
	dey
	bpl     L028E
;
; video_buffer_number = 0;
;
	lda     #$00
;
; else
;
	jmp     L0709
;
; OS.sdlst = &display_list1;
;
L027F:	lda     #>(_display_list1)
	sta     $0230+1
	lda     #<(_display_list1)
	sta     $0230
;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; memset(video_ptr2, EMPTY_TILE, SCREEN_SIZE_X * SCREEN_SIZE_Y);
;
	lda     _video_ptr2
	ldx     _video_ptr2+1
	jsr     pushax
	lda     #$7E
	jsr     pusha0
	ldx     #$03
	lda     #$C0
	jsr     _memset
;
; memcpy(video_lookup, video_lookup2, sizeof(video_lookup));
;
	ldy     #$2F
L029F:	lda     _video_lookup2,y
	sta     _video_lookup,y
	dey
	bpl     L029F
;
; video_buffer_number = 1;
;
	lda     #$01
L0709:	sta     _video_buffer_number
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ switch_music (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_switch_music: near

.segment	"BANKCODE"

;
; audio_sfx(SFX_CLICK);
;
	lda     #$01
	jsr     _audio_sfx
;
; wait_time(25);
;
	lda     #$19
	jsr     _wait_time
;
; audio_only_sfx = audio_only_sfx ? false : true;
;
	lda     _audio_only_sfx
	beq     L02EF
	lda     #$00
	jmp     L070A
L02EF:	lda     #$01
L070A:	sta     _audio_only_sfx
;
; if (audio_only_sfx)
;
	lda     _audio_only_sfx
	beq     L070B
;
; audio_music(MUSIC_SFX_ONLY);
;
	lda     #$05
	jmp     _audio_music
;
; if (game_progress.landed_on_world_number == SHUTTLE_IN_SPACE)
;
L070B:	lda     _game_progress+5
	cmp     #$FF
	bne     L070C
;
; audio_music(MUSIC_GALAXY);
;
	lda     #$01
	jmp     _audio_music
;
; audio_music(MUSIC_LEVEL_1 + game_progress.landed_on_world_number % MUSIC_LEVEL_MAX);
;
L070C:	lda     _game_progress+5
	jsr     pusha0
	lda     #$03
	jsr     tosumoda0
	clc
	adc     #$02
	jmp     _audio_music

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ perform_undo (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_perform_undo: near

.segment	"BANKCODE"

;
; set_timer(8);
;
	lda     #$08
	jsr     _set_timer
;
; HIDE_REDO_ICON();
;
	lda     #$F0
	sta     $D001
;
; if (undo())
;
	jsr     _undo
	tax
	beq     L070F
;
; if (undo_redo_counter == 0)
;
	lda     _undo_redo_counter
	bne     L070E
;
; undo_redo_counter = 1;
;
	lda     #$01
	sta     _undo_redo_counter
;
; SHOW_UNDO_ICON();
;
	lda     #$C5
;
; else
;
	jmp     L070D
;
; undo_redo_counter = 0;
;
L070E:	lda     #$00
	sta     _undo_redo_counter
;
; HIDE_UNDO_ICON();
;
	lda     #$F0
L070D:	sta     $D000
;
; init_level();
;
	jsr     _init_level
;
; set_gray_palette();
;
	jsr     _set_gray_palette
;
; audio_sfx(SFX_CLICK);
;
	lda     #$01
	jsr     _audio_sfx
;
; wait_for_timer();
;
	jsr     _wait_for_timer
;
; return true;
;
	ldx     #$00
	lda     #$01
	rts
;
; HIDE_UNDO_ICON();
;
L070F:	lda     #$F0
	sta     $D000
;
; return false;
;
	txa
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ perform_redo (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_perform_redo: near

.segment	"BANKCODE"

;
; set_timer(8);
;
	lda     #$08
	jsr     _set_timer
;
; HIDE_UNDO_ICON();
;
	lda     #$F0
	sta     $D000
;
; if (redo())
;
	jsr     _redo
	tax
	beq     L0712
;
; if (undo_redo_counter == 0)
;
	lda     _undo_redo_counter
	bne     L0711
;
; undo_redo_counter = 1;
;
	lda     #$01
	sta     _undo_redo_counter
;
; SHOW_REDO_ICON();
;
	lda     #$C5
;
; else
;
	jmp     L0710
;
; undo_redo_counter = 0;
;
L0711:	lda     #$00
	sta     _undo_redo_counter
;
; HIDE_REDO_ICON();
;
	lda     #$F0
L0710:	sta     $D001
;
; init_level();
;
	jsr     _init_level
;
; set_gray_palette();
;
	jsr     _set_gray_palette
;
; audio_sfx(SFX_CLICK);
;
	lda     #$01
	jsr     _audio_sfx
;
; wait_for_timer();
;
	jmp     _wait_for_timer
;
; HIDE_REDO_ICON();
;
L0712:	lda     #$F0
	sta     $D001
;
; audio_sfx(SFX_CLICK);
;
	lda     #$01
	jsr     _audio_sfx
;
; you_move_direction = DIR_NONE;
;
	lda     #$04
	sta     _you_move_direction
;
; set_timer(TIMER_VALUE); // normal "waiting move", therefore set standard timer
;
	lda     #$0C
	jmp     _set_timer

.endproc

; ---------------------------------------------------------------
; void __near__ store_undo_data (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_store_undo_data: near

.segment	"BANKCODE"

;
; if (undo_data_stored_this_turn==false)
;
	lda     _undo_data_stored_this_turn
	bne     L0713
;
; store_state();
;
	jsr     _store_state
;
; undo_data_stored_this_turn = true;
;
L0713:	lda     #$01
	sta     _undo_data_stored_this_turn
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ test_quit (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_test_quit: near

.segment	"BANKDATA"

L040A:
	.res	1,$00

.segment	"BANKCODE"

;
; byte quit_counter = 10;
;
	lda     #$0A
	sta     L040A
;
; if (quit_counter == 0 || OS.ch == 28)
;
L0714:	lda     L040A
	beq     L0715
	lda     $02FC
	cmp     #$1C
	beq     L0715
	lda     #$00
	jmp     L0716
;
; return true;
;
L0715:	ldx     #$00
	lda     #$01
	rts
;
; joy_status = joy_read(JOY_1);
;
L0716:	jsr     _joy_read
	sta     _joy_status
;
; if (JOY_BTN_1(joy_status) && JOY_UP(joy_status))
;
	ldx     #$00
	and     #$10
	beq     L071A
	lda     _joy_status
	and     #$01
	beq     L071A
;
; --quit_counter;
;
	dec     L040A
;
; fade_to_black_one_step();
;
	jsr     _fade_to_black_one_step
;
; wait_for_vblank();
;
	jsr     _wait_for_vblank
;
; you_move_direction = DIR_CREATED;
;
	lda     #$20
	sta     _you_move_direction
;
; else
;
	jmp     L0714
;
; if (quit_counter < 10)
;
L071A:	lda     L040A
	cmp     #$0A
	bcs     L071B
;
; palette_can_be_modified = true;
;
	lda     #$01
	sta     _palette_can_be_modified
;
; fade_palette_to_level_colors();
;
	jsr     _fade_palette_to_level_colors
;
; return false;
;
	ldx     #$00
L071B:	txa
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ draw_tile (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_draw_tile: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; local_temp1 = local_y * 2;
;
	lda     _local_y
	asl     a
	sta     _local_temp1
;
; array_ptr = video_lookup[local_temp1];
;
	ldx     #$00
	lda     _local_temp1
	asl     a
	bcc     L0722
	inx
	clc
L0722:	adc     #<(_video_lookup)
	sta     ptr1
	txa
	adc     #>(_video_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _array_ptr+1
	dey
	lda     (ptr1),y
	sta     _array_ptr
;
; local_temp1 = tile_to_set;
;
	lda     (sp),y
	sta     _local_temp1
;
; lookup_index = tiles_inverse[(local_temp1 % 128)/2];
;
	ldx     #$00
	and     #$7F
	lsr     a
	sta     ptr1
	txa
	clc
	adc     #>(_tiles_inverse)
	sta     ptr1+1
	ldy     #<(_tiles_inverse)
	lda     (ptr1),y
	sta     _lookup_index
;
; array_ptr += local_x * 2;
;
	lda     _local_x
	asl     a
	bcc     L0723
	inx
	clc
L0723:	adc     _array_ptr
	sta     _array_ptr
	txa
	adc     _array_ptr+1
	sta     _array_ptr+1
;
; *array_ptr = local_temp1 + ((lookup_index & 0x1) ? 128 : 0);
;
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$01
	beq     L04CF
	lda     #$80
L04CF:	clc
	adc     _local_temp1
	ldy     #$00
	sta     (ptr1),y
;
; array_ptr[1] = local_temp1 + ((lookup_index & 0x2) ? 129 : 1);
;
	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$02
	beq     L0725
	lda     #$81
	jmp     L04D8
L0725:	lda     #$01
L04D8:	clc
	adc     _local_temp1
	iny
	sta     (ptr1),y
;
; array_ptr[SCREEN_SIZE_X] = local_temp1 + ((lookup_index & 0x4) ? 128 : 0);
;
	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$04
	beq     L04E1
	lda     #$80
L04E1:	clc
	adc     _local_temp1
	ldy     #$28
	sta     (ptr1),y
;
; array_ptr[SCREEN_SIZE_X+1] = local_temp1 + ((lookup_index & 0x8) ? 129 : 1);
;
	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$08
	beq     L0727
	lda     #$81
	jmp     L04EA
L0727:	lda     #$01
L04EA:	clc
	adc     _local_temp1
	iny
	sta     (ptr1),y
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ draw_tile2 (unsigned char)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_draw_tile2: near

.segment	"BANKCODE"

;
; {
;
	jsr     pusha
;
; lookup_index = tiles_inverse[(tile_to_set % 128) / 2];
;
	ldy     #$00
	lda     (sp),y
	ldx     #$00
	and     #$7F
	lsr     a
	sta     ptr1
	txa
	clc
	adc     #>(_tiles_inverse)
	sta     ptr1+1
	ldy     #<(_tiles_inverse)
	lda     (ptr1),y
	sta     _lookup_index
;
; local_temp2 = local_y * 2;
;
	lda     _local_y
	asl     a
	sta     _local_temp2
;
; array_ptr = video_lookup[local_temp2];
;
	asl     a
	bcc     L072D
	inx
	clc
L072D:	adc     #<(_video_lookup)
	sta     ptr1
	txa
	adc     #>(_video_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _array_ptr+1
	dey
	lda     (ptr1),y
	sta     _array_ptr
;
; local_temp1 = local_x * 2;
;
	lda     _local_x
	asl     a
	sta     _local_temp1
;
; array_ptr += local_temp1;
;
	clc
	adc     _array_ptr
	sta     _array_ptr
	tya
	adc     _array_ptr+1
	sta     _array_ptr+1
;
; *array_ptr = tile_to_set + ((lookup_index & 0x1) ? 128 : 0);
;
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$01
	beq     L0500
	lda     #$80
L0500:	clc
	adc     (sp),y
	sta     (ptr1),y
;
; array_ptr[1] = tile_to_set + ((lookup_index & 0x2) ? 129 : 1);
;
	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$02
	beq     L072F
	lda     #$81
	jmp     L0509
L072F:	lda     #$01
L0509:	clc
	adc     (sp),y
	iny
	sta     (ptr1),y
;
; array_ptr += SCREEN_SIZE_X;
;
	lda     #$28
	clc
	adc     _array_ptr
	sta     _array_ptr
	bcc     L050D
	inc     _array_ptr+1
;
; *array_ptr = tile_to_set + ((lookup_index & 0x4) ? 128 : 0);
;
L050D:	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$04
	beq     L0514
	lda     #$80
L0514:	clc
	dey
	adc     (sp),y
	sta     (ptr1),y
;
; array_ptr[1] = tile_to_set + ((lookup_index & 0x8) ? 129 : 1);
;
	lda     _array_ptr+1
	sta     ptr1+1
	lda     _array_ptr
	sta     ptr1
	lda     _lookup_index
	and     #$08
	beq     L0731
	lda     #$81
	jmp     L051D
L0731:	lda     #$01
L051D:	clc
	adc     (sp),y
	iny
	sta     (ptr1),y
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ open_and_test_file_io (void)
; ---------------------------------------------------------------

.segment	"BANKCODE"

.proc	_open_and_test_file_io: near

.segment	"BANKCODE"

;
; file_read_pointer = open(tile_info_file_name, O_RDONLY);
;
	jsr     decsp4
	lda     _tile_info_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _tile_info_file_name+1
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_read_pointer
	stx     _file_read_pointer+1
;
; read(file_read_pointer, atari_tiles_info, sizeof(atari_tiles_info));
;
	jsr     decsp4
	lda     _file_read_pointer
	ldy     #$02
	sta     (sp),y
	iny
	lda     _file_read_pointer+1
	sta     (sp),y
	lda     #<(_atari_tiles_info)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(_atari_tiles_info)
	sta     (sp),y
	ldx     #$00
	lda     #$36
	jsr     _read
;
; close(file_read_pointer);
;
	lda     _file_read_pointer
	ldx     _file_read_pointer+1
	jsr     _close
;
; file_read_pointer = open(level_file_name, O_RDONLY);
;
	jsr     decsp4
	lda     _level_file_name
	ldy     #$02
	sta     (sp),y
	iny
	lda     _level_file_name+1
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	iny
	lda     #$00
	sta     (sp),y
	ldy     #$04
	jsr     _open
	sta     _file_read_pointer
	stx     _file_read_pointer+1
;
; }
;
	rts

.endproc

